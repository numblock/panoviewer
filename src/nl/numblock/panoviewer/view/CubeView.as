/***	Copyright (c) 2009 Maarten Reijmerink, http://www.numblock.nl**	Permission is hereby granted, free of charge, to any person obtaining a copy*	of this software and associated documentation files (the "Software"), to deal*	in the Software without restriction, including without limitation the rights*	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell*	copies of the Software, and to permit persons to whom the Software is*	furnished to do so, subject to the following conditions:*	*	The above copyright notice and this permission notice shall be included in*	all copies or substantial portions of the Software.*	*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,*	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE*	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,*	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN*	THE SOFTWARE.* */package nl.numblock.panoviewer.view {	import nl.numblock.DebugInterests;	import nl.numblock.panoviewer.interfaces.ICubeController;	import nl.numblock.panoviewer.interfaces.IImageData;	import nl.numblock.util.debug.Debugger;	import com.hydrotik.queueloader.QueueLoaderEvent;	import org.papervision3d.core.clipping.FrustumClipping;	import org.papervision3d.core.proto.MaterialObject3D;	import org.papervision3d.materials.utils.MaterialsList;	import org.papervision3d.objects.primitives.Cube;	import org.papervision3d.view.BasicView;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.ui.Keyboard;	/**	 * @author numblock	 */	public class CubeView extends BasicView	{		private var __model 				: 	IImageData;		private var __controller 			: 	ICubeController;		private var __cube 					: 	Cube;		private var __mouseDown 			: 	Boolean	= 	false;		private var __mouseOriginX 			: 	Number	=	0;		private var __mouseOriginY 			: 	Number	=	0;		private var __diffX 				: 	Number 	= 	0;		private var __diffY 				: 	Number	= 	0;		private var __zoomIn 				: 	Boolean	=	false;		private var __zoomOut 				: 	Boolean	=	false;		private var __highQuality 			: 	Boolean	=	false;				private static const ZOOM_FACTOR	:	Number	=	0.5;		private static const MIN_FOV		:	Number	=	35;		private static const MAX_FOV		:	Number 	= 	130;		private static const QUALITY_DELTA	:	Number 	= 	0.05;		public function CubeView	(											_model			:	IImageData,										_controller		:	ICubeController	=	null,										_viewportWidth	:	Number			=	640, 										_viewportHeight : 	Number 			= 	480, 										_scaleToStage 	: 	Boolean 		= 	true, 										_interactive 	: 	Boolean 		= 	false, 										_cameraType 	: 	String 			= 	"Free"									) 		{			super( _viewportWidth, _viewportHeight, _scaleToStage, _interactive, _cameraType);			__model			=	_model;			__controller	=	_controller;						__model.addEventListener(QueueLoaderEvent.QUEUE_COMPLETE, 	onQueueComplete);						init3D();		}				private function init3D() : void 		{			camera.z			= 	0;			camera.useClipping	=	true;			renderer.clipping 	= 	new FrustumClipping(FrustumClipping.ALL);		}				private function onQueueComplete(event : QueueLoaderEvent) : void 		{			if(__cube == null)			{				buildCube(__model.materialsList);				buildInteraction();			} else {				replaceMaterials(__model.materialsList);			}		}				private function buildCube( _materialsList : MaterialsList) : void		{			__cube										=	new Cube(_materialsList);			__cube.x	=	__cube.y	=	__cube.z	=	0;			scene.addChild(__cube);						startRendering();		}				private function replaceMaterials( _materialsList : MaterialsList) : void 		{			for each (var mat : MaterialObject3D in _materialsList.materialsByName)			{				__cube.replaceMaterialByName(mat, mat.name);			}		}		private function buildInteraction() : void 		{			stage.addEventListener(KeyboardEvent.KEY_DOWN, 	onKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP, 	onKeyUp);			stage.addEventListener(MouseEvent.MOUSE_DOWN, 	onMouseDown);			stage.addEventListener(MouseEvent.MOUSE_UP, 	onMouseUp);		}				private function onMouseUp(event : MouseEvent) : void 		{			__mouseDown		=	false;		}		private function onMouseDown( _event : MouseEvent) : void 		{			__mouseOriginX	=	this.mouseX;			__mouseOriginY	=	this.mouseY;			__mouseDown		=	true;		}				private function onKeyUp( _event : KeyboardEvent ) : void 		{			switch(_event.keyCode)			{				case Keyboard.SHIFT		:					__zoomIn	=	false;				break;				case Keyboard.CONTROL	:					__zoomOut	=	false;				break;			}		}		private function onKeyDown( _event : KeyboardEvent ) : void 		{			switch(_event.keyCode)			{				case Keyboard.SHIFT		:					__zoomIn	=	true;				break;				case Keyboard.CONTROL	:					__zoomOut	=	true;				break;			}		}		override protected function onRenderTick(_event:Event=null):void		{			if(__zoomIn && camera.fov > MIN_FOV) 			{					camera.fov				-=	ZOOM_FACTOR;			}			if(__zoomOut && camera.fov < MAX_FOV) 			{				camera.fov			+=	ZOOM_FACTOR;			}						if(__mouseDown)			{				__diffX		=	Math.round(__mouseOriginX - this.mouseX);				__diffY		=	Math.round(__mouseOriginY - this.mouseY);			} else {				__diffX		=	(__diffX - (__diffX / 20));				__diffY		=	(__diffY - (__diffY / 20));			}//						var targetRotationX	:	Number	=	camera.rotationX - (__diffY/100);			var targetRotationY	:	Number	=	(camera.rotationY - (__diffX/100));						if(targetRotationX <= 89 && targetRotationX >= -89)			{				camera.rotationX		=	targetRotationX;			}			camera.rotationY		=	targetRotationY;						super.onRenderTick( _event);		}			}}