/***	Copyright (c) 2009 Maarten Reijmerink, http://www.numblock.nl**	Permission is hereby granted, free of charge, to any person obtaining a copy*	of this software and associated documentation files (the "Software"), to deal*	in the Software without restriction, including without limitation the rights*	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell*	copies of the Software, and to permit persons to whom the Software is*	furnished to do so, subject to the following conditions:*	*	The above copyright notice and this permission notice shall be included in*	all copies or substantial portions of the Software.*	*	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,*	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE*	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,*	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN*	THE SOFTWARE.* */package nl.numblock.panoviewer.model {	import fl.motion.MatrixTransformer;	import nl.numblock.DebugInterests;	import nl.numblock.panoviewer.interfaces.IImageData;	import nl.numblock.panoviewer.model.vo.AppDataVO;	import nl.numblock.util.debug.Debugger;	import com.hydrotik.queueloader.QueueLoader;	import com.hydrotik.queueloader.QueueLoaderEvent;	import org.papervision3d.materials.BitmapMaterial;	import org.papervision3d.materials.utils.MaterialsList;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.Matrix;	/**	 * @author numblock	 */	public class ImageLoaderProxy extends QueueLoader implements IImageData	{		private var __materialsList 	: 	MaterialsList;		private static const faces	 	: 	Array			=	[																	{ id : "f",	name : "front"	},																	{ id : "r",	name : "right"	},																	{ id : "b",	name : "back"	},																	{ id : "l",	name : "left"	},																	{ id : "t",	name : "top"	},																	{ id : "d",	name : "bottom"	}																];				public function ImageLoaderProxy () 		{			super();		}		public function loadImages( _appData : AppDataVO ) : void 		{			materialsList			=	new MaterialsList();			if( _loadingQueue.length > 0 ) 			{				stop();				dispose();			}						for each (var face : Object in faces)			{				var fullPath	:	String	=	_appData.filePath + _appData.prefix + "_" + face.id + ".jpg";				addItem(fullPath, new Sprite, {id : face.name});			}			addEventListener(QueueLoaderEvent.ITEM_COMPLETE, 	onImageComplete);//			TODO: mmm create popupview to display load error and make it listen to this: //			addEventListener(QueueLoaderEvent.ITEM_ERROR, onItemError);			execute();		}				private function onImageComplete( _event : QueueLoaderEvent) : void 		{			var myImage	:	DisplayObject		=	_event.content;//			flip horizontally, cos we're viewing inside of cube			var horizontalFlip	:	Matrix		=	new Matrix();			MatrixTransformer.scaleAroundExternalPoint(horizontalFlip, myImage.width/2, myImage.height/2, -1, 1);			if(_event.info.id == "top")			{				MatrixTransformer.rotateAroundExternalPoint(horizontalFlip, myImage.width/2, myImage.height/2, 180);			}			var myBitmapData	:	BitmapData	=	new BitmapData(myImage.width, myImage.height);			myBitmapData.draw(myImage,	horizontalFlip);						var myMat	:	BitmapMaterial		=	new BitmapMaterial(myBitmapData);			myMat.name							=	_event.info.id;			myMat.precise						=	true;			myMat.smooth 						= 	true;			myMat.opposite 						= 	true;			__materialsList.addMaterial(myMat, _event.info.id);		}		public function get materialsList() : MaterialsList		{			return __materialsList;		}				public function set materialsList( _materialsList : MaterialsList ) :void		{			__materialsList	=	_materialsList;		}	}}